import numpy as np
import pandas as pd
import random as rand

plase_zone = np.array ([[5,6,7],[2,3,4],[100,1,100]])
min_val = 1
plase_zone = plase_zone - min_val
matrix_dist = np.zeros((7, 7))
summ = np.zeros(7)
dist = np.zeros(7)
summ_c = np.zeros(7)
queue = np.zeros(7)

for i in range(0,3):
    for j in range(0,3):
        element = plase_zone[i][j] 
        if element >= 99: continue
        for m in range(0, 3):
            for n in range(0, 3):
                element2 = plase_zone[m][n]
                if element2 >= 99: continue
                matrix_dist[element][element2] = abs(i - m) + abs(j - n)
                
for i in range(0,7):
    for j in range(0,7):
        summ[i] = summ[i] + matrix_dist[i][j]
        
index = np.array([1,2,3,4,5,6,7])
matrix_summ = np.zeros((7, 2))
for i in range(7):
    for j in range(2):
        if j == 0:
            matrix_summ[i][j] = index[i]
        else:
            matrix_summ[i][j] = summ[i]
matrix_summ = np.array(sorted(matrix_summ, key=lambda x :x[-1]))

for i in range(7):
    for j in range(1):
       dist[i] = matrix_summ[i][j]

c = np.zeros((7, 7))
c[0][0] = 0
c[0][1] = np.floor(100/6) + 1 + np.floor(100/7) + 1
c[0][2] = np.floor(100/7) + 1
c[0][3] = np.floor(100/6) + 1 + np.floor(100/7) + 1
c[0][4] = np.floor(100/7) + 1
c[0][5] = np.floor(100/7) + 1
c[0][6] = np.floor(100/6) + 1 + np.floor(100/7) + 1

c[1][0] = c[0][1]
c[1][1] = 0
c[1][2] = 3 * (np.floor(100/2) + 1) + np.floor(100/3) + 1
c[1][3] = np.floor(100/6) + 1 + np.floor(100/7) + 1 + np.floor(100/3) + 1
c[1][4] = 0
c[1][5] = np.floor(100/7) + 1
c[1][6] = np.floor(100/6) + 1

c[2][0] = c[0][2]
c[2][1] = c[1][2]
c[2][2] = 0
c[2][3] = np.floor(100/3) + 1
c[2][4] = 0
c[2][5] = 0
c[2][6] = 0

c[3][0] = c[0][3]
c[3][1] = c[1][3]
c[3][2] = c[2][3]
c[3][3] = 0
c[3][4] = 3 * (np.floor(100/2) + 1) + np.floor(100/3) + 1
c[3][5] = np.floor(100/7) + 1 + np.floor(100/3) + 1
c[3][6] = np.floor(100/6) + 1

c[4][0] = c[0][4]
c[4][1] = c[1][4]
c[4][2] = c[2][4]
c[4][3] = c[3][4]
c[4][4] = 0
c[4][5] = 0
c[4][6] = 0

c[5][0] = c[0][5]
c[5][1] = c[1][5]
c[5][2] = c[2][5]
c[5][3] = c[3][5]
c[5][4] = c[4][5]
c[5][5] = 0
c[5][6] = 3 * (np.floor(100/2) + 1)

c[6][0] = c[0][6]
c[6][1] = c[1][6]
c[6][2] = c[2][6]
c[6][3] = c[3][6]
c[6][4] = c[4][6]
c[6][5] = c[5][6]
c[6][6] = 0

for i in range(0,7):
    for j in range(0,7):
        summ_c[i] = summ_c[i] + c[i][j]
        
matrix_summ2 = np.zeros((7, 2))
for i in range(7):
    for j in range(2):
        if j == 0:
            matrix_summ2[i][j] = index[i]
        else:
            matrix_summ2[i][j] = summ_c[i]
matrix_summ2 = np.array(sorted(matrix_summ2, key=lambda x :x[-1]))

for i in range(7):
    for j in range(1):
       queue[i] = matrix_summ2[i][j]
       
def component_vector(position):
    if position == 0:
        return 2, 1
    if position == 1:
        return 1, 0
    if position == 2:
        return 1, 1
    if position == 3:
        return 1, 2
    if position == 4:
        return 0, 0
    if position == 5:
        return 0, 1
    if position == 6:
        return 0, 2

def distance_matrix(position_vector):
    dist_matrix = [[0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0]]
    for i in range(1, 8):
        for j in range(1, 8):
            x1, y1 = component_vector(position_vector.index(i))
            x2, y2 = component_vector(position_vector.index(j))
            dist_matrix[i-1][j-1] = abs(x2-x1) + abs(y2-y1)
    return dist_matrix

def find_optimum():
    vector = []
    func_min = 100000000000
    for _ in range(100):
        func = 0
        pos_vector = [2, 3, 4, 5, 6, 7]
        rand.shuffle(pos_vector)
        pos_vector.insert(0, 1)
        matrix = distance_matrix(pos_vector)
        for i in range(7):
            for j in range(7):
                func = func + c[i][j] * matrix[i][j]
        if func < func_min:
            func_min = func
            vector = pos_vector
    print(vector)
    print(func_min)

find_optimum()
