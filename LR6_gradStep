import numpy as np
from math import pi, sqrt

def volume(x):
    return pi*(x[0]**2)*x[1]

#def volume_r(x):
   # return 2 * pi * x[0] * x[1]

#def volume_h(x):
  #  return pi * (x[0] ** 2)

def gradient_volume(x):
    return np.array([2 * pi * x[0] * x[1], pi * (x[0] ** 2)])

def square(x):
    return 2*pi*x[0]*(x[0]+x[1])

#def square_r(x):
#    return 4 * pi * x[0] + 2 * pi * x[1]

#def square_h(x):
#    return 2 * pi * x[0]

def gradient_square(x):
    return np.array([4 * pi * x[0] + 2 * pi * x[1], 2 * pi * x[0]])

def gradient_length(GR):
    return np.sqrt(GR[0] ** 2 + GR[1] ** 2)
    
def bisection(x):
    eps = 0.000001 #константа различимости (подбирали)
    length = 0.000003 #конечная длина интервала неопределенности (подбирали)
    a = 0
    b = 10
    gradient = gradient_square(x)
    while b - a > length:
        lambd = (a+b)/2 - eps
        mu = (a+b)/2 + eps
        f_lambd = square(x - lambd * gradient)
        f_mu = square(x - mu * gradient) 
        if f_lambd < f_mu:
            b = mu
        else:
            a = lambd
    return (a+b)/2
    
eps = 0.01
x = np.array([50, 50]) #r = x[0], h = x[1]
GR = gradient_square(x)
step = bisection(x)

while gradient_length(GR) > 138:
    x = x - step * GR
    while x[0] <= 0 or x[1] <= 0:
        gradient_H = np.array([0, 0])
        if x[0] < 0: 
            gradient_H[0] = 1
        if x[1] < 0: 
            gradient_H[1] = 1
        x = x + 1/10 * gradient_H
    while volume(x) < 1000:
        m = x[0]
        n = x[1]
        gradient_V = gradient_volume(x)
        x = x + step/10000 * gradient_V 
    if abs(m-x[0]) < eps and abs(n-x[1]) < eps:
        break
    GR = gradient_square(x)
    step = bisection(x) 

print(f"r = {x[0]}, h = {x[1]}, S = {square(x)}, V = {volume(x)}") 
